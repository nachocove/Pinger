diff --git a/Pinger/exchange.go b/Pinger/exchange.go
index 7a8bc80..98da535 100644
--- a/Pinger/exchange.go
+++ b/Pinger/exchange.go
@@ -321,7 +321,7 @@ func (ex *ExchangeClient) LongPoll(stopPollCh, stopAllCh chan int, errCh chan er
 	ex.transport = &http.Transport{
 		TLSClientConfig: &tls.Config{
 			InsecureSkipVerify: false,
-			RootCAs:            globals.config.RootCerts(),
+			//RootCAs:            globals.config.RootCerts(),
 		},
 		ResponseHeaderTimeout: time.Duration(reqTimeout) * time.Millisecond,
 	}
diff --git a/Pinger/imap.go b/Pinger/imap.go
index 14a1a21..ec9e809 100644
--- a/Pinger/imap.go
+++ b/Pinger/imap.go
@@ -21,22 +21,22 @@ import (
 
 // IMAP Commands
 const (
-	IMAP_EXISTS       string = "EXISTS"
-	IMAP_EXPUNGE      string = "EXPUNGE"
-	IMAP_EXAMINE      string = "EXAMINE"
-	IMAP_IDLE         string = "IDLE"
-	IMAP_DONE         string = "DONE"
-	IMAP_NOOP         string = "NOOP"
-	IMAP_UIDNEXT      string = "[UIDNEXT"
-	IMAP_STATUS       string = "STATUS"
+	IMAP_EXISTS string = "EXISTS"
+	IMAP_EXPUNGE string = "EXPUNGE"
+	IMAP_EXAMINE string = "EXAMINE"
+	IMAP_IDLE string = "IDLE"
+	IMAP_DONE string = "DONE"
+	IMAP_NOOP string = "NOOP"
+	IMAP_UIDNEXT string = "[UIDNEXT"
+	IMAP_STATUS string = "STATUS"
 	IMAP_STATUS_QUERY string = "(MESSAGES UIDNEXT)"
 )
 
 // Timeout values for the Dial functions.
 const (
-	netTimeout       = 30 * time.Second // Time to establish a TCP connection
-	POLLING_INTERVAL = 30
-	replyTimeout     = 300 * time.Second // Time to wait on server response
+	netTimeout = 30 * time.Second // Time to establish a TCP connection
+	DEFAULT_SLEEP_INTERVAL = 30
+	replyTimeout = 300 * time.Second // Time to wait on server response
 )
 
 type cmdTag struct {
@@ -62,10 +62,12 @@ type IMAPClient struct {
 
 var prng *rand.Rand
 var commandTerminator []byte
+var IOTimeoutError error
 
 func init() {
 	prng = rand.New(&prngSource{src: rand.NewSource(time.Now().UnixNano())})
 	commandTerminator = []byte("\r\n")
+	IOTimeoutError = fmt.Errorf("I/O Timeout Error")
 }
 
 func (imap *IMAPClient) getLogPrefix() string {
@@ -130,7 +132,7 @@ func genNewCmdTag(n uint) *cmdTag {
 	if n < 1 || 26 < n {
 		n = 5
 	}
-	id := make([]byte, n, n+20)
+	id := make([]byte, n, n + 20)
 	for i, v := range prng.Perm(26)[:n] {
 		id[i] = 'A' + byte(v)
 	}
@@ -191,15 +193,16 @@ func (imap *IMAPClient) doImapAuth() (authSucess bool, err error) {
 		imap.Error("Error decoding AuthBlob")
 		return false, err
 	}
-	responses, err := imap.doIMAPCommand(fmt.Sprintf("%s %s", imap.tag.Next(), decodedBlob), uint64(replyTimeout/time.Millisecond))
+	responses, err := imap.doIMAPCommand(fmt.Sprintf("%s %s", imap.tag.Next(), decodedBlob), uint64(replyTimeout / time.Millisecond))
 	if err != nil {
 		return false, err
 	}
 	if len(responses) > 0 {
-		lastResponse := responses[len(responses)-1]
-		if imap.isContinueResponse(lastResponse) { // auth failed
+		lastResponse := responses[len(responses) - 1]
+		if imap.isContinueResponse(lastResponse) {
+			// auth failed
 			imap.Debug("Authentication failed: %s", lastResponse)
-			responses, err = imap.doIMAPCommand(" ", uint64(replyTimeout/time.Millisecond))
+			responses, err = imap.doIMAPCommand(" ", uint64(replyTimeout / time.Millisecond))
 		}
 		if !imap.isOKResponse(lastResponse) {
 			return false, err
@@ -215,7 +218,7 @@ func (imap *IMAPClient) parseEXAMINEResponse(response string) (value uint32, tok
 	if tokens[0] == "*" && tokens[2] == IMAP_EXISTS {
 		valueToken = tokens[1]
 	} else if tokens[0] == "*" && tokens[2] == IMAP_UIDNEXT {
-		valueToken = tokens[3][:len(tokens[3])-1]
+		valueToken = tokens[3][:len(tokens[3]) - 1]
 	}
 	if valueToken != "" {
 		value, err := strconv.Atoi(valueToken)
@@ -266,7 +269,7 @@ func (imap *IMAPClient) parseIDLEResponse(response string) (value uint32, token
 func (imap *IMAPClient) doExamine() error {
 	command := fmt.Sprintf("%s %s %s", imap.tag.Next(), IMAP_EXAMINE, imap.pi.IMAPFolderName)
 	imap.Debug("IMAPFolder=%s", imap.pi.IMAPFolderName)
-	_, err := imap.doIMAPCommand(command, uint64(replyTimeout/time.Millisecond))
+	_, err := imap.doIMAPCommand(command, uint64(replyTimeout / time.Millisecond))
 	return err
 }
 
@@ -316,7 +319,7 @@ func (imap *IMAPClient) doIMAPCommand(command string, waitTime uint64) ([]string
 			allResponses = append(allResponses, responses...)
 		}
 		if len(responses) > 0 {
-			lastResponse := responses[len(responses)-1]
+			lastResponse := responses[len(responses) - 1]
 			if !imap.isOKResponse(lastResponse) && !imap.isContinueResponse(lastResponse) {
 				err := fmt.Errorf("Did not get proper response from imap server: %s", lastResponse)
 				imap.Debug("%s", err)
@@ -342,8 +345,8 @@ func (imap *IMAPClient) processResponse(command string, response string) {
 			imap.Info("%s received. Decrementing count|IMAPEXISTSCount=%d", IMAP_EXPUNGE, imap.pi.IMAPEXISTSCount)
 
 		} else if token == IMAP_EXISTS && count != imap.pi.IMAPEXISTSCount {
-			imap.Info("Current EXISTS count is different from starting EXISTS count."+
-				"Resetting count|currentIMAPEXISTSCount=%d|startingIMAPExistsCount=%d", count, imap.pi.IMAPEXISTSCount)
+			imap.Info("Current EXISTS count is different from starting EXISTS count." +
+			"Resetting count|currentIMAPEXISTSCount=%d|startingIMAPExistsCount=%d", count, imap.pi.IMAPEXISTSCount)
 			imap.Info("Got new mail. Stopping IDLE|msgCode=IMAP_NEW_MAIL")
 			imap.hasNewEmail = true
 			imap.pi.IMAPEXISTSCount = count
@@ -370,8 +373,8 @@ func (imap *IMAPClient) processResponse(command string, response string) {
 				imap.Info("Setting starting IMAPUIDNEXT|IMAPUIDNEXT=%d", UIDNext)
 				imap.pi.IMAPUIDNEXT = UIDNext
 			} else if UIDNext != imap.pi.IMAPUIDNEXT {
-				imap.Info("Current UIDNext is different from starting UIDNext."+
-					" Resetting UIDNext|currentUIDNext=%d|startingUIDNext=%d|msgCode=IMAP_RESET_UIDNEXT", UIDNext, imap.pi.IMAPUIDNEXT)
+				imap.Info("Current UIDNext is different from starting UIDNext." +
+				" Resetting UIDNext|currentUIDNext=%d|startingUIDNext=%d|msgCode=IMAP_RESET_UIDNEXT", UIDNext, imap.pi.IMAPUIDNEXT)
 				imap.Info("Got new mail|msgCode=IMAP_NEW_MAIL")
 				imap.hasNewEmail = true
 				imap.pi.IMAPUIDNEXT = UIDNext
@@ -464,7 +467,8 @@ func (imap *IMAPClient) getServerResponse(waitTime uint64) (string, error) {
 				imap.Debug("Timeout error|err=%s", nerr)
 				return "", err
 			} else if ok && nerr.Temporary() {
-				if i < 3 { // try three times
+				if i < 3 {
+					// try three times
 					imap.Info("Temporary error scanning for server response: %s. Will retry...", nerr)
 					time.Sleep(time.Duration(1) * time.Second)
 				} else {
@@ -508,8 +512,8 @@ func (imap *IMAPClient) doRequestResponse(request string, responseCh chan []stri
 	}
 	imap.mutex.Unlock()
 	unlockMutex = false
-	imap.Debug("Executing IMAP Command|timeout=%d", uint64(replyTimeout/time.Millisecond))
-	responses, err := imap.doIMAPCommand(request, uint64(replyTimeout/time.Millisecond))
+	imap.Debug("Executing IMAP Command|timeout=%d", uint64(replyTimeout / time.Millisecond))
+	responses, err := imap.doIMAPCommand(request, uint64(replyTimeout / time.Millisecond))
 	if imap.cancelled == true {
 		imap.Info("IMAP Request cancelled. Exiting|msgCode=IMAP_REQ_CANCELLED")
 		return
@@ -519,7 +523,12 @@ func (imap *IMAPClient) doRequestResponse(request string, responseCh chan []stri
 			imap.isIdling = false
 		}
 		imap.Info("Request/Response Error: %s", err)
-		responseErrCh <- fmt.Errorf("Request/Response Error: %s", err)
+		nerr, ok := err.(net.Error)
+		if ok && nerr.Timeout() {
+			responseErrCh <- IOTimeoutError;
+		} else {
+			responseErrCh <- fmt.Errorf("Request/Response Error: %s", err)
+		}
 		return
 	}
 	responseCh <- responses
@@ -544,7 +553,7 @@ func (imap *IMAPClient) setupConn() error {
 	if imap.tlsConfig == nil {
 		imap.tlsConfig = &tls.Config{
 			ServerName: host,
-			RootCAs:    globals.config.RootCerts(),
+			//RootCAs:    globals.config.RootCerts(),
 		}
 	}
 	conn, err := net.DialTimeout("tcp", imap.url.Host, netTimeout)
@@ -595,7 +604,7 @@ func (imap *IMAPClient) LongPoll(stopPollCh, stopAllCh chan int, errCh chan erro
 			imap.Debug("Sleeping %s before retry", s)
 			time.Sleep(s)
 		}
-		sleepTime = POLLING_INTERVAL
+		sleepTime = DEFAULT_SLEEP_INTERVAL
 		if imap.tlsConn == nil {
 			err := imap.setupConn()
 			if err != nil {
@@ -624,9 +633,8 @@ func (imap *IMAPClient) LongPoll(stopPollCh, stopAllCh chan int, errCh chan erro
 				return
 			}
 		}
-		reqTimeout := imap.pi.ResponseTimeout
-		reqTimeout += uint64(float64(reqTimeout) * 0.1) // add 10% so we don't step on the HeartbeatInterval inside the ping
-		requestTimer := time.NewTimer(time.Duration(reqTimeout) * time.Millisecond)
+		imap.Info("Request timeout %d|msgCode=IMAP_POLL_REQ_TIMEDOUT_VALUE", imap.pi.ResponseTimeout)
+		requestTimer := time.NewTimer(time.Duration(imap.pi.ResponseTimeout) * time.Millisecond)
 		responseCh := make(chan []string)
 		responseErrCh := make(chan error)
 		command := IMAP_NOOP
@@ -638,16 +646,21 @@ func (imap *IMAPClient) LongPoll(stopPollCh, stopAllCh chan int, errCh chan erro
 
 		go imap.doRequestResponse(command, responseCh, responseErrCh)
 		select {
-		case <-requestTimer.C:
-			// request timed out. Start over.
+		case <-requestTimer.C: // request timed out. Start over.
 			imap.Info("Request timed out. Starting over|msgCode=IMAP_POLL_REQ_TIMEDOUT")
 			requestTimer.Stop()
 			imap.cancelIDLE()
+			sleepTime = 1
 
 		case err := <-responseErrCh:
-			imap.Info("Got error %s. Sending back LongPollReRegister|msgCode=IMAP_ERR_REREGISTER", err)
-			errCh <- LongPollReRegister // erroring out... ask for reregister
-			return
+			if err == IOTimeoutError {
+				// just retry on an I/O Timeout. No need for the device to re-register
+				sleepTime = 1
+			} else {
+				imap.Info("Got error %s. Sending back LongPollReRegister|msgCode=IMAP_ERR_REREGISTER", err)
+				errCh <- LongPollReRegister // erroring out... ask for reregister
+				return
+			}
 
 		case <-responseCh:
 			if imap.hasNewEmail {
diff --git a/Pinger/mailClient.go b/Pinger/mailClient.go
index fea18cd..ee33142 100644
--- a/Pinger/mailClient.go
+++ b/Pinger/mailClient.go
@@ -138,10 +138,10 @@ func NewMailClientContext(dbm *gorp.DbMap, aws AWS.AWSHandler, pi *MailPingInfor
 		sessionId:       pi.SessionId,
 	}
 	err := aws.ValidateCognitoID(pi.UserId)
-	if err != nil {
-		client.Info("Could not validate user id:%s|userId=%s|msgCode=INVALID_USERID", err.Error(), pi.UserId)
-		return nil, err
-	}
+	//if err != nil {
+		//client.Info("Could not validate user id:%s|userId=%s|msgCode=INVALID_USERID", err.Error(), pi.UserId)
+		//return nil, err
+	//}
 
 	client.logger.SetCallDepth(1)
 
diff --git a/main/pinger-webserver/devices.go b/main/pinger-webserver/devices.go
index 7d1b545..657dc83 100644
--- a/main/pinger-webserver/devices.go
+++ b/main/pinger-webserver/devices.go
@@ -157,6 +157,7 @@ func isValidClientContext(context string) bool {
 }
 
 func isValidPushToken(pushService, pushToken string) bool {
+	return true
 	if pushService == PUSH_SERVICE_APNS {
 		decodedToken, err := AWS.DecodeAPNSPushToken(pushToken)
 		if err != nil {
diff --git a/scripts/betaprov.json b/scripts/betaprov.json
index 35700d4..4b599bd 100644
--- a/scripts/betaprov.json
+++ b/scripts/betaprov.json
@@ -141,7 +141,7 @@
         }
     },
     "autoscale_config": {
-        "ami_id": "ami-f9b04599",
+        "ami_id": "ami-f6ff0d96",
         "key_pair": "BetaPinger",
         "instance_type": "m3.medium",
         "instance_monitoring": false,
diff --git a/scripts/prodprov.json b/scripts/prodprov.json
index 52befd3..2f2bc5e 100644
--- a/scripts/prodprov.json
+++ b/scripts/prodprov.json
@@ -145,7 +145,7 @@
         }
     },
     "autoscale_config": {
-        "ami_id": "ami-f9b04599",
+        "ami_id": "ami-f6ff0d96",
         "key_pair": "ProdPinger",
         "instance_type": "m3.medium",
         "instance_monitoring": false,
